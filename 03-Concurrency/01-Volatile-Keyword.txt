====================================================================
                            CONCURRENCY: VOLATILE KEYWORD
====================================================================

INTRODUCTION:
The volatile keyword in Java is used to indicate that a variable's value may be modified by different threads. It ensures visibility of changes to variables across threads and prevents certain compiler optimizations that could lead to incorrect behavior in multithreaded environments.

KEY CONCEPTS:

1. VISIBILITY PROBLEM:
   - Each thread may cache variables in CPU registers/cache
   - Changes made by one thread may not be visible to others
   - volatile ensures changes are written to main memory immediately
   - Other threads read fresh value from main memory

2. VOLATILE GUARANTEES:
   - Visibility: Changes are immediately visible to all threads
   - Prevents compiler optimizations that could reorder operations
   - Atomic read/write operations (for references and primitives â‰¤ 32 bits)
   - Happens-before relationship establishment

3. VOLATILE vs SYNCHRONIZED:
   - volatile: Only ensures visibility, not atomicity of compound operations
   - synchronized: Ensures both visibility and atomicity
   - volatile is lighter weight than synchronized
   - volatile cannot be used for method synchronization

4. WHEN TO USE VOLATILE:
   - Flag variables (boolean flags)
   - Status indicators
   - Configuration values
   - Single writer, multiple readers scenarios
   - When you need visibility but not atomicity

5. VOLATILE LIMITATIONS:
   - Does not guarantee atomicity for compound operations (++, --)
   - Cannot replace synchronized for complex critical sections
   - No mutual exclusion (locking)
   - Performance impact due to memory barriers

EXAMPLE CODE:

// Without volatile - may cause infinite loop
class WithoutVolatile {
    private boolean running = true;
    
    public void startThread() {
        Thread worker = new Thread(() -> {
            while (running) {  // May read cached value forever
                // Do work
                doWork();
            }
            System.out.println("Thread stopped");
        });
        worker.start();
        
        // Main thread
        try {
            Thread.sleep(1000);
            running = false;  // Change may not be visible to worker thread
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void doWork() {
        // Simulate work
    }
}

// With volatile - ensures visibility
class WithVolatile {
    private volatile boolean running = true;  // volatile ensures visibility
    
    public void startThread() {
        Thread worker = new Thread(() -> {
            while (running) {  // Always reads fresh value from main memory
                doWork();
            }
            System.out.println("Thread stopped");
        });
        worker.start();
        
        // Main thread
        try {
            Thread.sleep(1000);
            running = false;  // Change immediately visible to all threads
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void doWork() {
        // Simulate work
    }
}

// Volatile for status checking
class StatusChecker {
    private volatile String status = "INITIALIZING";
    
    public void updateStatus(String newStatus) {
        this.status = newStatus;  // Immediately visible to all threads
    }
    
    public String getStatus() {
        return status;  // Always returns fresh value
    }
}

// Double-checked locking with volatile
class Singleton {
    private static volatile Singleton instance;  // volatile prevents reordering
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {  // First check without locking
            synchronized (Singleton.class) {
                if (instance == null) {  // Second check with locking
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

// Volatile limitations - not atomic for compound operations
class Counter {
    private volatile int count = 0;
    
    // NOT thread-safe despite volatile
    public void increment() {
        count++;  // This is read-modify-write, not atomic
    }
    
    // Thread-safe version
    public synchronized void safeIncrement() {
        count++;
    }
    
    // Or use AtomicInteger
    private final AtomicInteger atomicCount = new AtomicInteger(0);
    
    public void atomicIncrement() {
        atomicCount.incrementAndGet();  // Thread-safe
    }
}

// Producer-Consumer with volatile flag
class ProducerConsumer {
    private volatile boolean dataReady = false;
    private String data;
    
    // Producer thread
    public void produce() {
        data = "Important Data";
        dataReady = true;  // Signal that data is ready
    }
    
    // Consumer thread
    public void consume() {
        while (!dataReady) {  // Wait for data to be ready
            Thread.yield();
        }
        System.out.println("Consumed: " + data);
    }
}

====================================================================
                            MCQ QUESTIONS
====================================================================

1. What is the primary purpose of volatile keyword?
   a) Make variables immutable
   b) Ensure thread safety
   c) Ensure visibility across threads
   d) Prevent memory leaks
   Answer: c) Ensure visibility across threads

2. Where are volatile variables stored?
   a) CPU cache only
   b) Main memory
   c) Thread-local storage
   d) Stack memory
   Answer: b) Main memory

3. What problem does volatile solve?
   a) Race conditions
   b) Deadlocks
   c) Visibility problem
   d) Memory leaks
   Answer: c) Visibility problem

4. Can volatile be used with methods?
   a) Yes, for any method
   b) Yes, only static methods
   c) No, only with variables
   d) Yes, only instance methods
   Answer: c) No, only with variables

5. Is volatile sufficient for thread-safe counter increment?
   a) Yes, always
   b) No, increment is not atomic
   c) Only for single-threaded
   d) Only with synchronized
   Answer: b) No, increment is not atomic

6. What does volatile prevent?
   a) Method calls
   b) Compiler optimizations that affect visibility
   c) Object creation
   d) Memory allocation
   Answer: b) Compiler optimizations that affect visibility

7. Which is lighter weight?
   a) volatile
   b) synchronized
   c) Both are same
   d) Neither
   Answer: a) volatile

8. What relationship does volatile establish?
   a) Parent-child
   b) Happens-before
   c) Is-a
   d) Has-a
   Answer: b) Happens-before

9. Can volatile guarantee atomicity for long/double variables?
   a) Yes, always
   b) No, never
   c) Yes, in 64-bit JVMs
   d) Only with synchronized
   Answer: c) Yes, in 64-bit JVMs

10. What happens without volatile in multi-threading?
    a) Compilation error
    b) Runtime exception
    c) Variables may be cached, causing visibility issues
    d) Memory corruption
    Answer: c) Variables may be cached, causing visibility issues

11. Which operation is atomic with volatile?
    a) increment (++)
    b) compound assignment (+=)
    c) read/write of reference
    d) decrement (--)
    Answer: c) read/write of reference

12. When should you use volatile?
    a) For all variables in multi-threaded code
    b) For flag variables and status indicators
    c) Instead of synchronized always
    d) For performance optimization
    Answer: b) For flag variables and status indicators

13. What is double-checked locking?
    a) Locking twice for safety
    b. Optimization pattern for lazy initialization
    c) Two different locks
    d) Checking lock twice
    Answer: b) Optimization pattern for lazy initialization

14. Why is volatile needed in double-checked locking?
    a) For performance
    b) To prevent instruction reordering
    c) For thread safety
    d) To avoid deadlock
    Answer: b) To prevent instruction reordering

15. Can volatile replace synchronized completely?
    a) Yes, always
    b) No, only for simple visibility cases
    c) Only in single-threaded code
    d) Yes, but with performance cost
    Answer: b) No, only for simple visibility cases

16. What is the performance impact of volatile?
    a) No impact
    b) Significant improvement
    c) Slight overhead due to memory barriers
    d) Major performance degradation
    Answer: c) Slight overhead due to memory barriers

17. Which is true about volatile arrays?
    a) All elements are volatile
    b) Only array reference is volatile
    c) Array length is volatile
    d) Nothing is volatile
    Answer: b) Only array reference is volatile

18. Can you have volatile static variables?
    a) Yes
    b) No
    c) Only in interfaces
    d) Only final static
    Answer: a) Yes

19. What does memory barrier ensure?
    a) Memory allocation
    b) Ordering of memory operations
    c) Memory cleanup
    d) Memory optimization
    Answer: b) Ordering of memory operations

20. Which scenario is ideal for volatile?
    a) Multiple writers, multiple readers
    b) Single writer, multiple readers
    c) Complex critical sections
    d) Compound operations
    Answer: b) Single writer, multiple readers

21. What happens if you don't use volatile for shared flag?
    a) Compilation error
    b) Thread may not see updated value
    c) Runtime exception
    d) Memory leak
    Answer: b) Thread may not see updated value

22. Is volatile transitive?
    a) Yes, affects all related variables
    b) No, only affects marked variable
    c) Sometimes
    d) Depends on JVM
    Answer: b) No, only affects marked variable

23. Can volatile be used with final?
    a) Yes, they complement each other
    b) No, they are mutually exclusive
    c) Only for static variables
    d) Only for instance variables
    Answer: b) No, they are mutually exclusive

24. What is volatile's effect on JIT optimization?
    a) Enables more optimizations
    b) Prevents certain optimizations
    c) No effect
    d) Improves optimization
    Answer: b) Prevents certain optimizations

25. Which is the correct volatile usage pattern?
    a) volatile int count = 0; count++;
    b) volatile boolean flag = false; flag = true;
    c) volatile List<String> list; list.add("item");
    d) All are correct
    Answer: b) volatile boolean flag = false; flag = true;

====================================================================