====================================================================
                        ITERATOR AND COLLECTIONS UTILITY
====================================================================

INTRODUCTION:
Iterator provides a way to traverse collections in a standardized manner. Collections utility class provides static methods for common operations on collections like sorting, searching, and synchronization.

KEY CONCEPTS:

1. ITERATOR INTERFACE:
   - Universal way to traverse collections
   - Methods: hasNext(), next(), remove()
   - Fail-fast behavior (detects concurrent modifications)
   - Safer than traditional for loops for removal

2. LISTITERATOR INTERFACE:
   - Extends Iterator for List collections
   - Bidirectional traversal
   - Methods: hasPrevious(), previous()
   - Can add, set, and remove elements during iteration

3. ENHANCED FOR LOOP (for-each):
   - Simplified syntax for iteration
   - Internally uses Iterator
   - Cannot modify collection during iteration
   - More readable code

4. COLLECTIONS UTILITY CLASS:
   - Static utility methods for collections
   - Algorithms: sort(), binarySearch(), reverse()
   - Synchronization: synchronizedList(), synchronizedMap()
   - Immutable collections: unmodifiableList(), unmodifiableSet()
   - Empty collections: emptyList(), emptySet(), emptyMap()

5. FAIL-FAST vs FAIL-SAFE:
   - Fail-fast: Throws ConcurrentModificationException
   - Fail-safe: Creates copy, allows concurrent modification
   - Most collections are fail-fast

EXAMPLE CODE:

// Iterator example
List<String> list = Arrays.asList("A", "B", "C", "D");
Iterator<String> iterator = list.iterator();

while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
    // Safe removal during iteration
    if (element.equals("B")) {
        iterator.remove();
    }
}

// ListIterator example
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4));
ListIterator<Integer> listIterator = numbers.listIterator();

// Forward traversal
while (listIterator.hasNext()) {
    int num = listIterator.next();
    if (num == 2) {
        listIterator.set(20);  // Replace 2 with 20
    }
    if (num == 3) {
        listIterator.add(25);  // Add 25 after 3
    }
}

// Backward traversal
while (listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}

// Enhanced for loop
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
    // Cannot modify collection here
}

// Collections utility methods
List<Integer> nums = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5));

// Sorting
Collections.sort(nums);                    // [1, 1, 3, 4, 5]
Collections.sort(nums, Collections.reverseOrder()); // [5, 4, 3, 1, 1]

// Custom sorting
Collections.sort(names, (a, b) -> a.length() - b.length());

// Binary search (requires sorted list)
int index = Collections.binarySearch(nums, 3);

// Other operations
Collections.reverse(nums);                 // Reverse order
Collections.shuffle(nums);                 // Random shuffle
Collections.fill(nums, 0);                // Fill with zeros
int frequency = Collections.frequency(nums, 1); // Count occurrences

// Min and Max
Integer min = Collections.min(nums);
Integer max = Collections.max(nums);

// Synchronization wrappers
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());

// Unmodifiable collections
List<String> unmodifiableList = Collections.unmodifiableList(names);
Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(new HashMap<>());

// Empty collections
List<String> emptyList = Collections.emptyList();
Set<String> emptySet = Collections.emptySet();
Map<String, String> emptyMap = Collections.emptyMap();

// Singleton collections
List<String> singletonList = Collections.singletonList("OnlyElement");
Set<String> singletonSet = Collections.singleton("OnlyElement");

// Checking disjoint collections
boolean disjoint = Collections.disjoint(list1, list2);

// Copying collections
Collections.copy(destination, source);

====================================================================
                            MCQ QUESTIONS
====================================================================

1. What is the primary purpose of Iterator?
   a) Store elements
   b) Traverse collections
   c) Sort collections
   d) Create collections
   Answer: b) Traverse collections

2. Which method checks if Iterator has more elements?
   a) hasMore()
   b) hasNext()
   c) moreElements()
   d) next()
   Answer: b) hasNext()

3. What happens if you modify collection during enhanced for loop?
   a) Nothing
   b) Compilation error
   c) ConcurrentModificationException
   d) Elements are skipped
   Answer: c) ConcurrentModificationException

4. Which interface allows bidirectional traversal?
   a) Iterator
   b) ListIterator
   c) BiIterator
   d) DoubleIterator
   Answer: b) ListIterator

5. What does fail-fast behavior mean?
   a) Iterator fails quickly
   b) Detects concurrent modifications and throws exception
   c) Iterator is fast
   d) Iterator never fails
   Answer: b) Detects concurrent modifications and throws exception

6. Which method removes current element during iteration?
   a) delete()
   b) remove()
   c) erase()
   d) clear()
   Answer: b) remove()

7. What is the Collections class?
   a) Interface for collections
   b) Abstract class for collections
   c) Utility class with static methods
   d) Implementation of Collection
   Answer: c) Utility class with static methods

8. Which method sorts a List?
   a) Collections.sort()
   b) List.sort()
   c) Both a and b
   d) Collections.order()
   Answer: c) Both a and b

9. What does Collections.binarySearch() require?
   a) Any list
   b) Sorted list
   c) Unique elements
   d) Numeric elements
   Answer: b) Sorted list

10. Which method creates thread-safe version of ArrayList?
    a) Collections.threadSafe()
    b) Collections.synchronizedList()
    c) Collections.safeList()
    d) Collections.lockedList()
    Answer: b) Collections.synchronizedList()

11. What does Collections.unmodifiableList() return?
    a) Empty list
    b) Copy of list
    c) Read-only view of list
    d) Synchronized list
    Answer: c) Read-only view of list

12. Which method finds minimum element in collection?
    a) Collections.min()
    b) Collections.minimum()
    c) Collections.smallest()
    d) Collections.findMin()
    Answer: a) Collections.min()

13. What does Collections.frequency() do?
    a) Sets frequency of elements
    b) Counts occurrences of element
    c) Gets collection frequency
    d) Creates frequency map
    Answer: b) Counts occurrences of element

14. Can you use remove() method on Iterator for all collections?
    a) Yes, always
    b) No, never
    c) Only if collection supports removal
    d) Only for Lists
    Answer: c) Only if collection supports removal

15. What happens when you call next() without checking hasNext()?
    a) Returns null
    b) Returns first element
    c) NoSuchElementException may be thrown
    d) Compilation error
    Answer: c) NoSuchElementException may be thrown

16. Which method reverses the order of elements?
    a) Collections.reverse()
    b) Collections.invert()
    c) Collections.flip()
    d) Collections.backward()
    Answer: a) Collections.reverse()

17. What does Collections.shuffle() do?
    a) Sorts elements
    b) Randomly reorders elements
    c) Removes duplicates
    d) Groups similar elements
    Answer: b) Randomly reorders elements

18. How do you create empty immutable list?
    a) new ArrayList()
    b) Collections.emptyList()
    c) Arrays.asList()
    d) List.of()
    Answer: b) Collections.emptyList()

19. What does Collections.disjoint() check?
    a) If collections are same
    b) If collections have common elements
    c) If collections have no common elements
    d) If collections are sorted
    Answer: c) If collections have no common elements

20. Which is true about ListIterator?
    a) Only forward traversal
    b) Only backward traversal
    c) Bidirectional traversal
    d) Random access
    Answer: c) Bidirectional traversal

21. What does Collections.copy() do?
    a) Creates copy of collection
    b) Copies elements from source to destination
    c) Copies collection structure
    d) Deep copies all elements
    Answer: b) Copies elements from source to destination

22. Can enhanced for loop be used with arrays?
    a) Yes
    b) No
    c) Only object arrays
    d) Only primitive arrays
    Answer: a) Yes

23. What happens if you try to modify unmodifiable collection?
    a) Nothing
    b) Changes are ignored
    c) UnsupportedOperationException
    d) Compilation error
    Answer: c) UnsupportedOperationException

24. Which method creates singleton collection?
    a) Collections.single()
    b) Collections.singleton()
    c) Collections.one()
    d) Collections.alone()
    Answer: b) Collections.singleton()

25. What is the time complexity of Collections.sort()?
    a) O(n)
    b) O(n log n)
    c) O(nÂ²)
    d) O(log n)
    Answer: b) O(n log n)

====================================================================